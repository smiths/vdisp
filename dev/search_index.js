var documenterSearchIndex = {"docs":
[{"location":"#vdisp.jl","page":"vdisp.jl","title":"vdisp.jl","text":"","category":"section"},{"location":"","page":"vdisp.jl","title":"vdisp.jl","text":"vdisp.readInputFile\nCalculationBehaviour.getEffectiveStress\nCalculationBehaviour.getSurchargePressure\nCalculationBehaviour.getValue\nCalculationBehaviour.schmertmannApproximation","category":"page"},{"location":"#vdisp.readInputFile","page":"vdisp.jl","title":"vdisp.readInputFile","text":"readInputFile(inputPath, outputPath)\n\nReads and parses input file at inputPath and outputs calculations to file at outputPath.\n\nThis function was used to emulate old VDispl software's CLI funcitonality. It is no longer  used in this version of VDisp. It has been left in for any developers that would like to have the command line funcitonality.\n\n\n\n\n\n","category":"function"},{"location":"#Main.CalculationBehaviour.getEffectiveStress","page":"vdisp.jl","title":"Main.CalculationBehaviour.getEffectiveStress","text":"getEffectiveStress(behaviour)\n\nCalculates the effective stress at each nodal point given values in the InputData instance contained in behaviour. Returns two identical  Float64 arrays (unless model is ConsolidationSwell and equilibrium moisture  profile is saturated above water table). VDisp never alters the second array so the original effective stress values are always available for each nodal point,  and alters the first array adding all other stress values to each corresponding nodal point.\n\nCalculations\n\nThe effective stress at depth z, sigma_z, is calculated using the following formulas:\n\nsigma_z = (gamma_sat-gamma_w)z\n\nWhich can be derived from the following equations:\n\nsigma_z = sigma_z + u_w\n\nu_w = gamma_w z\n\nsigma_z = gamma_sat z\n\nThis calculation is repeated at each depth increment.\n\nThe bulk unit weight, gamma, which is equal to gamma_sat-gamma_w  is calculated by the following formula:\n\ngamma = fracWV = fracG_s (1+w) gamma_w1+e\n\nVariables\n\nsigma_z: stress at depth z\n\nsigma_z: effective stress at depth z\n\ngamma_w: unit weight of water\n\ngamma_sat: unit weight of saturated soil\n\nG_s: specific gravity of soil\n\nw: water content of soil\n\ne: void ratio of soil\n\n\n\n\n\n","category":"function"},{"location":"#Main.CalculationBehaviour.getSurchargePressure","page":"vdisp.jl","title":"Main.CalculationBehaviour.getSurchargePressure","text":"getSurchargePressure(behaviour, P, PP)\n\nCalculates the stress after adding foundation at each nodal point below the foundation. The values are added to array P, while array PP remains unchanged. VDisp software  calls this function using P and PP returned from the getEffectiveStress() function.\n\nCalculations\n\nUsing the Boussinesq equation for stress at a point under the corner of a rectangular  area, the stress from adding the foundation is calculated at each depth increment. If the calculation must be done from the center (i.e. behaviour.center == true), the 2:1 method is used: length, a, and width, b, are halved, while the whole equation is  multiplied by a factor of 4 (the leading factor becomes frac2qpi rather than  fracq2pi. This is because the calculation in the center can be seen as splitting the rectangular area into 4 quadrants, where the original center is a corner for each  rectangle. Now the Boussinesq equation for stress at a point under the corner of a rectangular area can be used, however there are 4 of these rectangles contributing to the load, hence the multiplication by a factor of 4). The stress increase at depth z is denoted  as sigma_z, and is calculated using the following equation:\n\nsigma_z = fracq2 pi (texttan^-1(fracabzC)+fracabzC(frac1A^2+frac1B^2)) text where\n\nA^2 = a^2 + z^2\n\nB^2 = b^2 + z^2\n\nC = sqrta^2+b^2+z^2\n\nVariables\n\nq: net applied footing pressure\n\nsigma_z: stress increase at depth z\n\na: length of the foundation\n\nb: width of the foundation\n\nz: depth\n\n\n\n\n\n","category":"function"},{"location":"#Main.CalculationBehaviour.getValue","page":"vdisp.jl","title":"Main.CalculationBehaviour.getValue","text":"getValue(behaviour::ConsolidationSwellCalculationBehaviour)\n\nThis functions first calls getEffectiveStress() and getSurchargePressure() with behaviour as the argument to establish the two arrays P and PP. It then calculates total heave (Δh), subsoil movement (Δh2), and heave  above foundation (Δh1). It also calculates values at each depth increment and places them in two tables,  heaveAboveFoundationTable and heaveBelowFoundationTable. Returns tuple (P, PP, heaveAboveFoundationTable,  heaveBelowFoundationTable, Δh1, Δh2, Δh)\n\nCalculations\n\nDelta e_j = C_c log_10fracsigma_fjsigma_oj text if  sigma_fj  sigma_pj\n\nDelta e_j = C_r log_10fracsigma_pjsigma_oj + C_c log_10fracsigma_fjsigma_pj text if  sigma_fj ge sigma_pj\n\nsigma_oj = fracsigma_oj1 + sigma_oj22\n\nrho_cj = fracDelta e_j1 + e_0jH_j\n\nrho_c = sum_j=1^n rho_cj\n\nVariables\n\nDelta e_j: change in void ratio of soil layer j\n\ne_0j: initial void ratio of soil layer j\n\nsigma_oj: effectuve stress of layer j\n\nsigma_oj1: effective stress at top of layer j\n\nsigma_oj2: effective stress at bottom of layer j\n\nsigma_fj: final applied effective stress of layer j\n\nC_c: compression index\n\nC_r: recompression index\n\nrho_cj: one-dimensional consolidation of layer j\n\nrho_c: oen-dimensional consolidation of soil profile\n\nH_j: thickness of layer j\n\nn: number of layers\n\nNote: Tables heaveAboveFoundationTable and heaveBelowFoundationTable contain the following values in each row: j, fracdx2 + j times dx, fracrho_cjH_j, sigma_fj-sigma_oj\n\n\n\n\n\n","category":"function"},{"location":"#Main.CalculationBehaviour.schmertmannApproximation","page":"vdisp.jl","title":"Main.CalculationBehaviour.schmertmannApproximation","text":"schmertmannApproximation(behaviour, elasticModulusGiven, PP)\n\nCalculates settlement at each depth increment, rho_i, and sums it up to calculate total settlement, rho. If elasticModulus == true, input file must have elastic moduli, E_si, for each soil layer. Else, input file must  have cone penetration resistance data, q_ci, for each soil layer. Returns a 2D array of settlement values with each row  containing the element number, the depth of the layer, and it's settlement.\n\nCalculations\n\nThis subroutine calculates total settlement using the Schmertmann Approximation:\n\nrho = C_1 C_t Delta p Delta z sum_i=1^n fracI_izE_si text where \n\nC_1 = 1 - frac05 sigma_odDelta p C_1 ge 05\n\nC_t = 1 + 02 log_10 fract01\n\nE_si = 25 q_ci text if rectangular footing  35 q_ci text if long strip footing\n\nI_zp = 05 + 01 sqrtfracDelta psigma_izp\n\nI_iz = 0 text if  z  2w text frac43I_zp - fracI_zp z15w text if  z  05w text  else  01 + frac(I_zp-01)z05w\n\nsigma_izp = fracsigma_topi + sigma_boti2\n\nDelta p =  Q - sigma_od\n\nVariables\n\nC_1: correction to account for strain relief from embedment\n\nC_t: correction for time dependant inrease in settlement \n\nsigma_od: effective stress at bottom of foundation\n\nDelta p: net applied footing pressure\n\nQ: applied pressure \n\nt: time in years since construction\n\nDelta z: depth increment\n\nI_iz: influence factor of soil layer i\n\nE_si: elastic modulus of soil layer i \n\nq_ci: cone penetration resistance of soil layer i \n\nsigma_topi: effective stress at top of soil layer i\n\nsigma_boti: effective stress at bottom of soil layer i\n\nrho_i: settlement of soil layer i\n\nrho: total settlement\n\nCode\n\nThe code first calculates the settlement of each soil layer, rho_i, then sums up settlements at each depth increment. The following two formulas are used to achieve this:\n\nrho_i = C_1 C_t Delta p Delta z fracI_izE_si\n\nrho = sum_i=1^n rho_i\n\n\n\n\n\n","category":"function"},{"location":"","page":"vdisp.jl","title":"vdisp.jl","text":"Documentation for vdisp.jl","category":"page"}]
}
